// Generated by CoffeeScript 1.4.0
(function() {
  var convert, csv, csv2json, fs, iconv, json2csv, path, schema, _;

  _ = require('underscore');

  fs = require('yi-fs');

  path = require('path');

  iconv = require('iconv-lite');

  csv = require('yi-csv');

  convert = {};

  /**
   * json对象数组转换为csv文件
  */


  json2csv = (function() {

    function json2csv(jsonArr) {
      var self;
      self = this;
      self.jsonArr = jsonArr || [];
      self.csvText = '';
      self;

    }

    json2csv.prototype.fields = function(map) {
      var self;
      self = this;
      self.map = map;
      return self;
    };

    json2csv.prototype.toCSVText = function() {
      var self, text;
      self = this;
      text = [];
      if (!_.isArray(self.jsonArr)) {
        throw new Exception("the json input must be an array.");
      }
      self.jsonArr.forEach(function(json) {
        var item;
        if (self.map) {
          if (_.isFunction(self.map)) {
            item = self.map(json);
          } else {
            if (_.isObject(self.map)) {
              item = {};
              _.each(json, function(v, k, obj) {
                if (self.map[k]) {
                  return item[self.map[k]] = v;
                } else {
                  return item[k] = v;
                }
              });
            } else {
              item = json;
            }
          }
        } else {
          item = json;
        }
        if (!self.headers) {
          self.headers = _.keys(item);
          self.headers = self.headers.map(function(header) {
            return header.replace(/,/g, ' ');
          });
          text.push(self.headers.toString());
        }
        return text.push(((_.values(item)).map(function(val) {
          if (val != null) {
            return val.toString().replace(/,/g, ' ');
          } else {
            return '';
          }
        })).toString());
      });
      return text.join('\n');
    };

    json2csv.prototype.toCSVFile = function(target, options, callback) {
      var buf, content, filedir, self, _ref, _ref1;
      self = this;
      if (!callback && _.isFunction(options)) {
        callback = options;
        options = {};
        options.encode = 'utf8';
        options.mode = '0777';
      }
      content = self.toCSVText();
      buf = iconv.encode(content, (_ref = options.encode) != null ? _ref : options.encode = 'utf8');
      filedir = path.dirname(target);
      return fs.mkdirp(filedir, (_ref1 = options.mode) != null ? _ref1 : options.mode = '0777', function(err) {
        if (err) {
          if (callback) {
            return callback(err, content);
          }
        } else {
          return fs.writeFile(target, buf, function(err) {
            console.log("write json to file success.");
            if (callback) {
              return callback(err, content);
            }
          });
        }
      });
    };

    return json2csv;

  })();

  convert.json2csv = json2csv;

  /**
   * csv转换为json对象数组
  */


  csv2json = (function() {

    function csv2json(csvfile) {
      if (!fs.existsSync(csvfile)) {
        console.error(csvfile);
        throw "please input the valid csvfile param.";
      }
      this.csvfile = csvfile;
      this;

    }

    csv2json.prototype.fields = function(map) {
      if (_.isArray(map)) {
        this.keys = map;
      } else {
        this.headers = _.keys(map);
        this.keys = _.values(map);
        this.map = map;
      }
      return this;
    };

    csv2json.prototype.toJSON = function(options, callback) {
      var jsonArr, readCsv, self;
      self = this;
      if (!callback && _.isFunction(options)) {
        callback = options;
        options = {};
      }
      readCsv = new csv(self.csvfile).parse(options);
      jsonArr = [];
      readCsv.on('error', function(err) {
        return callback(err, jsonArr);
      });
      return readCsv.on('end', function(rows) {
        rows.forEach(function(row) {
          var newO;
          if (_.isArray(row)) {
            if (self.keys) {
              return jsonArr.push(_.object(self.keys, row));
            } else {
              return jsonArr.push(row);
            }
          } else {
            if (!self.keys) {
              return jsonArr.push(row);
            } else {
              if (!self.map) {
                return jsonArr.push(_.object(self.keys, _.values(row)));
              } else {
                newO = {};
                _.each(row, function(v, k, obj) {
                  if (self.map[k]) {
                    return newO[self.map[k]] = v;
                  } else {
                    return newO[k] = v;
                  }
                });
                return jsonArr.push(newO);
              }
            }
          }
        });
        return callback(null, jsonArr);
      });
    };

    return csv2json;

  })();

  convert.csv2json = csv2json;

  /**
   * schema验证和规格化
  */


  schema = (function() {

    function schema(fields_validation) {
      var self;
      if (fields_validation == null) {
        fields_validation = {};
      }
      self = this;
      self.fields_validation = fields_validation;
      self;

    }

    schema.prototype._SchemaTypes = {
      'String': String,
      'Number': Number,
      'Date': Date,
      'Buffer': Buffer,
      'Boolean': Boolean,
      'Mixed': Object,
      'ObjectId': require('mongodb').ObjectID,
      'Array': Array
    };

    schema.prototype.validate = function(obj) {};

    schema.prototype._format = function(val, format) {
      var dateutil, _id;
      if (format === 'String' || format === String) {
        if (typeof val === 'string') {
          return val;
        }
        if (typeof val === 'number') {
          return String(val);
        }
        if (val instanceof Date) {
          dateutil = require('date-utils');
          return val.toFormat('YYYY-MM-DD HH24:MI:SS');
        }
        if (Buffer.isBuffer(val)) {
          return val.toString();
        }
        if (_.isBoolean(val)) {
          return val.toString();
        }
        if (val instanceof Array) {
          return val.toString();
        }
        if (val instanceof require('mongodb').ObjectID) {
          return val.toString();
        }
        if (typeof val === 'object') {
          return JSON.stringify(val);
        }
      }
      if (format === 'Number' || format === Number) {
        if (typeof val === 'number' || (typeof val === 'string' && (!isNaN(Number(val))))) {
          return Number(val);
        } else {
          throw "" + val + " can not parse into a Number type";
        }
      }
      if (format === 'Date' || format === Date) {
        if (val instanceof Date || (new Date(val) instanceof Date)) {
          return new Date(val);
        } else {
          throw "" + val + " can not parse into a Date type";
        }
      }
      if (format === 'Buffer' || format === Buffer) {
        if (Buffer.isBuffer(val)) {
          return val;
        } else {
          if (_.isString(val)) {
            return new Buffer(val);
          } else {
            throw "" + val + " can not parse into a Buffer type";
          }
        }
      }
      if (format === 'Boolean' || format === Boolean) {
        if (val === true || val === 'true') {
          return true;
        } else {
          if (val === false || val === 'false') {
            return false;
          } else {
            throw "" + val + " can not parse into a Boolean type";
          }
        }
      }
      if (format === 'Array' || format === Array) {
        if (val instanceof Array) {
          return val;
        } else {
          if (_.isString(val)) {
            return val.split(',');
          } else {
            throw "" + val + " can not parse into a Array type";
          }
        }
      }
      if (format === 'ObjectId' || format === require('mongodb').ObjectID) {
        if (val instanceof require('mongodb').ObjectID) {
          return val;
        } else {
          _id = new require('mongodb').ObjectID(val);
        }
      }
      if (format === 'Mixed' || format === Object) {
        return val;
      }
    };

    schema.prototype.format = function(obj, allow_field_null) {
      var error, self;
      if (!obj || !_.isObject(obj)) {
        return;
      }
      error = null;
      self = this;
      _.each(self.fields_validation, function(config, field) {
        try {
          if (_.include((_.keys(self._SchemaTypes)).concat(_.values(self._SchemaTypes)), config)) {
            if (allow_field_null) {
              if (obj[field] != null) {
                return obj[field] = self._format(obj[field], config);
              }
            } else {
              if (obj[field] != null) {
                return obj[field] = self._format(obj[field], config);
              } else {
                throw "" + field + " must not be null";
              }
            }
          } else {
            if ((_.isObject(config)) && !_.isArray(config)) {
              if ((!(obj[field] != null)) && (config["default"] != null)) {
                obj[field] = config["default"];
              }
              if (config.required && !(obj[field] != null)) {
                throw "" + field + " must be required";
              }
              if (config.type) {
                if (obj[field] != null) {
                  return obj[field] = self._format(obj[field], config.type);
                }
              }
            }
          }
        } catch (e) {
          return error = e;
        }
      });
      if (error) {
        console.error(error);
      } else {
        return obj;
      }
    };

    return schema;

  })();

  convert.schema = schema;

  module.exports = convert;

}).call(this);
